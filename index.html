<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="robots" content="noindex,nofollow" />
    <title>Private Block Puzzle</title>
    <link rel="stylesheet" href="index.css" />
  </head>
  <body class="theme-dark">
    <div class="toast" id="toast"></div>

    <div
      class="modalback"
      id="modalback"
      role="dialog"
      aria-modal="true"
      aria-hidden="true"
    >
      <div class="modal">
        <div class="head">
          <div style="font-weight: 900">設定</div>
          <button class="btn small ghost" id="btnCloseModal">閉じる</button>
        </div>
        <div class="body">
          <div class="field">
            <div>
              <div style="font-weight: 900">演出</div>
              <div class="hint">軽さ優先なら Off 推奨</div>
            </div>
            <button class="switch" id="swEffects">Low</button>
          </div>
          <div class="hint">
            GitHub Pages
            は基本「公開URL」です。身内共有以外の用途にする場合は認証設計が必要になります。
          </div>
        </div>
        <div class="footer-actions">
          <button class="btn" id="btnResetBest">ベストをリセット</button>
          <button class="btn primary" id="btnOkModal">OK</button>
        </div>
      </div>
    </div>

    <div class="app">
      <!-- HOME -->
      <section class="screen active" id="screenHome">
        <div class="card home">
          <p class="title">Private Block Puzzle</p>
          <p class="sub">身内用・URL共有で遊ぶ Web パズル（広告なし）</p>

          <div
            class="card"
            style="
              padding: 14px;
              background: var(--panel2);
              border-color: rgba(255, 255, 255, 0.1);
            "
          >
            <div class="muted" style="font-weight: 800; font-size: 12px">
              自己ベスト
            </div>
            <div class="big" id="homeBest">0</div>
          </div>

          <div class="row">
            <button class="btn primary" id="btnStart" style="flex: 1">
              プレイ開始
            </button>
            <button class="btn" id="btnSettingsHome">設定</button>
          </div>

          <div class="hint">
            ルール：手持ちピースをドラッグして盤面へ配置。行/列が揃うと消えます。置けなくなったら終了。
          </div>
        </div>
      </section>

      <!-- GAME -->
      <section class="screen" id="screenGame">
        <div class="card game">
          <div class="hud">
            <div class="scorebox">
              <div class="score" id="score">0</div>
              <div class="best" id="best">Best: 0</div>
            </div>
            <div class="hud-meta">
              <div class="stat">
                <div class="label">レベル</div>
                <div class="value" id="level">1</div>
              </div>
              <div class="stat">
                <div class="label">残り時間</div>
                <div class="value" id="timer">1:30</div>
              </div>
              <div class="stat">
                <div class="label">残りライン</div>
                <div class="value" id="linesLeft">10</div>
              </div>
            </div>
            <div class="row" style="justify-content: flex-end; flex-wrap: wrap">
              <button class="btn small" id="btnUndo" disabled>Undo</button>
              <button class="btn small" id="btnRestart">リスタート</button>
              <button class="btn small" id="btnSettingsGame">設定</button>
            </div>
          </div>

          <div class="boardwrap">
            <div class="board" id="board" aria-label="board"></div>
          </div>

          <div class="fx-layer" id="fxLayer" aria-hidden="true"></div>

          <div class="tray" id="tray"></div>

          <div class="hint">
            操作のコツ：ピース上の「つかんだブロック」が、盤面のセルに吸着して置ける/置けないが色で分かります。
          </div>
        </div>
      </section>

      <!-- GAMEOVER -->
      <section class="screen" id="screenOver">
        <div class="card home">
          <p class="title">ゲーム終了</p>
          <p class="sub" id="overMsg">おつかれさまでした。</p>

          <div
            class="card"
            style="
              padding: 14px;
              background: var(--panel2);
              border-color: rgba(255, 255, 255, 0.1);
            "
          >
            <div class="muted" style="font-weight: 800; font-size: 12px">
              今回スコア
            </div>
            <div class="big" id="overScore">0</div>
            <div
              class="muted"
              style="font-weight: 800; font-size: 12px; margin-top: 10px"
            >
              自己ベスト
            </div>
            <div class="big" id="overBest">0</div>
          </div>

          <div class="row" style="align-items: stretch">
            <button class="btn primary" id="btnAgain" style="flex: 1">
              もう一回
            </button>
            <button class="btn" id="btnUndoOver">Undoして続ける</button>
          </div>

          <div class="row" style="align-items: stretch">
            <button class="btn" id="btnCopy" style="flex: 1">
              結果をコピー
            </button>
            <button class="btn" id="btnHome">ホーム</button>
          </div>

          <div class="hint">
            Undoは直前の1手のみ戻せます（1回使うと消費）。詰んだ時の救済として使えます。
          </div>
        </div>
      </section>
    </div>

    <script>
      (() => {
        const LS_BEST = "bb_private_v1_bestScore";
        const LS_SETTINGS = "bb_private_v1_settings";

        const DEFAULT_SETTINGS = {
          theme: "dark", // "dark" | "light"
          effects: "low", // "off" | "low" | "high"（現状は表示のみ。演出拡張時に使用）
        };
        const LEVEL_GOALS = [5, 8, 12];
        const MAX_LEVEL = LEVEL_GOALS.length;
        const TIMER_SECONDS = 90;

        // ===== Piece definitions (base + auto rotations) =====
        const BASE_SHAPES = [
          { key: "dot1", weight: 10, blocks: [{ x: 0, y: 0 }] },

          {
            key: "line2",
            weight: 10,
            blocks: [
              { x: 0, y: 0 },
              { x: 1, y: 0 },
            ],
          },
          {
            key: "line3",
            weight: 9,
            blocks: [
              { x: 0, y: 0 },
              { x: 1, y: 0 },
              { x: 2, y: 0 },
            ],
          },
          {
            key: "line4",
            weight: 7,
            blocks: [
              { x: 0, y: 0 },
              { x: 1, y: 0 },
              { x: 2, y: 0 },
              { x: 3, y: 0 },
            ],
          },
          {
            key: "line5",
            weight: 4,
            blocks: [
              { x: 0, y: 0 },
              { x: 1, y: 0 },
              { x: 2, y: 0 },
              { x: 3, y: 0 },
              { x: 4, y: 0 },
            ],
          },

          {
            key: "square2",
            weight: 8,
            blocks: [
              { x: 0, y: 0 },
              { x: 1, y: 0 },
              { x: 0, y: 1 },
              { x: 1, y: 1 },
            ],
          },

          {
            key: "rect3x2",
            weight: 5,
            blocks: [
              { x: 0, y: 0 },
              { x: 1, y: 0 },
              { x: 2, y: 0 },
              { x: 0, y: 1 },
              { x: 1, y: 1 },
              { x: 2, y: 1 },
            ],
          },

          {
            key: "L3",
            weight: 9,
            blocks: [
              { x: 0, y: 0 },
              { x: 0, y: 1 },
              { x: 1, y: 1 },
            ],
          },
          {
            key: "L4",
            weight: 6,
            blocks: [
              { x: 0, y: 0 },
              { x: 0, y: 1 },
              { x: 0, y: 2 },
              { x: 1, y: 2 },
            ],
          },

          {
            key: "T4",
            weight: 5,
            blocks: [
              { x: 0, y: 0 },
              { x: 1, y: 0 },
              { x: 2, y: 0 },
              { x: 1, y: 1 },
            ],
          },

          {
            key: "Z4",
            weight: 5,
            blocks: [
              { x: 0, y: 0 },
              { x: 1, y: 0 },
              { x: 1, y: 1 },
              { x: 2, y: 1 },
            ],
          },

          {
            key: "P5",
            weight: 3,
            blocks: [
              { x: 0, y: 0 },
              { x: 1, y: 0 },
              { x: 0, y: 1 },
              { x: 1, y: 1 },
              { x: 0, y: 2 },
            ],
          },

          {
            key: "plus5",
            weight: 2,
            blocks: [
              { x: 1, y: 0 },
              { x: 0, y: 1 },
              { x: 1, y: 1 },
              { x: 2, y: 1 },
              { x: 1, y: 2 },
            ],
          },
        ];

        const SHAPE_COLOR_MAP = {
          dot1: 1,
          line2: 2,
          line3: 3,
          line4: 4,
          line5: 5,
          square2: 6,
          rect3x2: 7,
          L3: 8,
          L4: 9,
          T4: 10,
          Z4: 11,
          P5: 12,
          plus5: 13,
        };

        function colorIdForShape(shapeKey) {
          return SHAPE_COLOR_MAP[shapeKey] || 1;
        }

        function normalizeBlocks(blocks) {
          const minX = Math.min(...blocks.map((b) => b.x));
          const minY = Math.min(...blocks.map((b) => b.y));
          const nb = blocks.map((b) => ({ x: b.x - minX, y: b.y - minY }));
          nb.sort((a, b) => a.y - b.y || a.x - b.x);
          const w = Math.max(...nb.map((b) => b.x)) + 1;
          const h = Math.max(...nb.map((b) => b.y)) + 1;
          return { blocks: nb, w, h };
        }

        function rotate90(blocks) {
          const r = blocks.map((b) => ({ x: b.y, y: -b.x }));
          return normalizeBlocks(r).blocks;
        }

        function blocksKey(blocks) {
          return blocks.map((b) => `${b.x},${b.y}`).join(";");
        }

        function genAllPieces() {
          const pieces = [];
          const seen = new Set();

          for (const base of BASE_SHAPES) {
            let cur = normalizeBlocks(base.blocks).blocks;
            for (let r = 0; r < 4; r++) {
              const n = normalizeBlocks(cur);
              const k = `${base.key}:${blocksKey(n.blocks)}`;
              if (!seen.has(k)) {
                seen.add(k);
                pieces.push({
                  shapeKey: base.key,
                  variantKey: `${base.key}_r${r}`,
                  colorId: colorIdForShape(base.key),
                  weight: base.weight,
                  blocks: n.blocks,
                  w: n.w,
                  h: n.h,
                });
              }
              cur = rotate90(cur);
            }
          }
          return pieces;
        }

        const ALL_PIECES = genAllPieces();
        const TOTAL_WEIGHT = ALL_PIECES.reduce((s, p) => s + p.weight, 0);

        function pickRandomPiece() {
          let r = Math.random() * TOTAL_WEIGHT;
          for (const p of ALL_PIECES) {
            r -= p.weight;
            if (r <= 0) return structuredClone(p);
          }
          return structuredClone(ALL_PIECES[ALL_PIECES.length - 1]);
        }

        // ===== DOM refs =====
        const el = {
          screenHome: document.getElementById("screenHome"),
          screenGame: document.getElementById("screenGame"),
          screenOver: document.getElementById("screenOver"),

          board: document.getElementById("board"),
          fxLayer: document.getElementById("fxLayer"),
          tray: document.getElementById("tray"),

          homeBest: document.getElementById("homeBest"),
          score: document.getElementById("score"),
          best: document.getElementById("best"),
          level: document.getElementById("level"),
          timer: document.getElementById("timer"),
          linesLeft: document.getElementById("linesLeft"),

          overMsg: document.getElementById("overMsg"),
          overScore: document.getElementById("overScore"),
          overBest: document.getElementById("overBest"),

          toast: document.getElementById("toast"),

          modalback: document.getElementById("modalback"),
          btnCloseModal: document.getElementById("btnCloseModal"),
          btnOkModal: document.getElementById("btnOkModal"),
          btnResetBest: document.getElementById("btnResetBest"),
          swEffects: document.getElementById("swEffects"),

          btnStart: document.getElementById("btnStart"),
          btnAgain: document.getElementById("btnAgain"),
          btnHome: document.getElementById("btnHome"),
          btnRestart: document.getElementById("btnRestart"),
          btnSettingsHome: document.getElementById("btnSettingsHome"),
          btnSettingsGame: document.getElementById("btnSettingsGame"),

          btnUndo: document.getElementById("btnUndo"),
          btnUndoOver: document.getElementById("btnUndoOver"),
          btnCopy: document.getElementById("btnCopy"),
        };

        function loadBest() {
          const v = Number(localStorage.getItem(LS_BEST) || "0");
          return Number.isFinite(v) ? v : 0;
        }
        function saveBest(v) {
          localStorage.setItem(LS_BEST, String(v));
        }

        function loadSettings() {
          try {
            const raw = localStorage.getItem(LS_SETTINGS);
            if (!raw) return { ...DEFAULT_SETTINGS };
            const obj = JSON.parse(raw);
            const s = { ...DEFAULT_SETTINGS, ...obj };
            s.theme = "dark";
            return s;
          } catch {
            return { ...DEFAULT_SETTINGS };
          }
        }
        function saveSettings(s) {
          localStorage.setItem(LS_SETTINGS, JSON.stringify(s));
        }

        // ===== App state =====
        const app = {
          view: "home",
          settings: loadSettings(),
          bestScore: loadBest(),
          level: 1,
          game: null,
          undo: null, // 直前状態のスナップショット（1手のみ）
          drag: { active: false },
          preview: [],
          timeLeft: TIMER_SECONDS,
          timerId: null,
          lastTick: 0,
          overMsgText: null,
        };

        function showScreen(name) {
          app.view = name;
          el.screenHome.classList.toggle("active", name === "home");
          el.screenGame.classList.toggle("active", name === "game");
          el.screenOver.classList.toggle("active", name === "over");
        }

        function toast(msg, ms = 900) {
          el.toast.textContent = msg;
          el.toast.style.display = "block";
          clearTimeout(toast._t);
          toast._t = setTimeout(() => {
            el.toast.style.display = "none";
          }, ms);
        }

        function applyTheme() {
          document.body.classList.remove("theme-light");
          document.body.classList.add("theme-dark");
          el.swEffects.textContent = app.settings.effects.toUpperCase();
        }

        function setUndoEnabled(enabled) {
          el.btnUndo.disabled = !enabled;
          el.btnUndoOver.disabled = !enabled;
        }

        function formatTime(sec) {
          const s = Math.max(0, Math.ceil(sec));
          const m = Math.floor(s / 60);
          const r = s % 60;
          return `${m}:${String(r).padStart(2, "0")}`;
        }

        function renderTimer() {
          if (!el.timer) return;
          el.timer.textContent = formatTime(app.timeLeft);
          el.timer.classList.toggle("danger", app.timeLeft <= 10);
        }

        function currentGoal() {
          return LEVEL_GOALS[Math.max(0, app.level - 1)] || LEVEL_GOALS[0];
        }

        function renderLines() {
          if (!el.linesLeft || !app.game) return;
          const left = Math.max(0, currentGoal() - app.game.linesCleared);
          el.linesLeft.textContent = String(left);
          el.linesLeft.classList.toggle("done", left === 0);
        }

        function renderLevel() {
          if (!el.level) return;
          el.level.textContent = `${app.level}/${MAX_LEVEL}`;
        }

        function stopTimer() {
          if (app.timerId) {
            clearInterval(app.timerId);
            app.timerId = null;
          }
        }

        function startTimer() {
          stopTimer();
          if (!app.game) return;
          app.lastTick = performance.now();
          app.timerId = setInterval(() => {
            if (!app.game || app.view !== "game") return;
            const now = performance.now();
            const delta = (now - app.lastTick) / 1000;
            app.lastTick = now;
            app.timeLeft = Math.max(0, app.timeLeft - delta);
            renderTimer();
            if (app.timeLeft <= 0) {
              endGame("時間切れ！");
            }
          }, 200);
        }

        function pauseTimer() {
          stopTimer();
        }

        function resumeTimer() {
          if (app.game && app.view === "game" && app.timeLeft > 0) {
            startTimer();
          }
        }

        function fxEnabled() {
          return app.settings.effects !== "off";
        }

        function fxStrong() {
          return app.settings.effects === "high";
        }

        function bumpScore() {
          if (!fxEnabled()) return;
          el.score.classList.remove("bump");
          void el.score.offsetWidth;
          el.score.classList.add("bump");
          clearTimeout(bumpScore._t);
          bumpScore._t = setTimeout(() => {
            el.score.classList.remove("bump");
          }, fxStrong() ? 320 : 220);
        }

        function flashBoard() {
          if (!fxEnabled()) return;
          el.board.classList.remove("flash", "flash-strong");
          void el.board.offsetWidth;
          el.board.classList.add("flash");
          if (fxStrong()) el.board.classList.add("flash-strong");
          setTimeout(() => {
            el.board.classList.remove("flash", "flash-strong");
          }, fxStrong() ? 320 : 220);
        }

        function fxPop(text, variant = "auto") {
          if (!fxEnabled()) return;
          const d = document.createElement("div");
          let cls = "fx-pop";
          if (variant === "mega") {
            cls += " mega";
          } else if (variant === "strong" || (variant === "auto" && fxStrong())) {
            cls += " strong";
          }
          d.className = cls;
          d.textContent = text;
          el.fxLayer.appendChild(d);
          d.addEventListener(
            "animationend",
            () => {
              d.remove();
            },
            { once: true }
          );
        }

        function fxFireworks(bursts = 1) {
          if (!fxEnabled()) return;
          const layerRect = el.fxLayer.getBoundingClientRect();
          const boardRect = el.board.getBoundingClientRect();
          const baseCount = fxStrong() ? 20 : 14;
          const baseDist = fxStrong() ? 120 : 90;
          const dur = fxStrong() ? 900 : 650;
          const burstNum = fxStrong() ? Math.max(2, bursts) : bursts;

          for (let b = 0; b < burstNum; b++) {
            const x =
              boardRect.left -
              layerRect.left +
              Math.random() * boardRect.width;
            const y =
              boardRect.top -
              layerRect.top +
              Math.random() * boardRect.height;
            const fw = document.createElement("div");
            fw.className = fxStrong() ? "fx-firework strong" : "fx-firework";
            fw.style.left = `${x}px`;
            fw.style.top = `${y}px`;

            for (let i = 0; i < baseCount; i++) {
              const ang = Math.random() * Math.PI * 2;
              const dist = baseDist * (0.45 + Math.random() * 0.65);
              const dx = Math.cos(ang) * dist;
              const dy = Math.sin(ang) * dist;
              const s = document.createElement("span");
              s.className = "spark";
              s.style.setProperty("--dx", `${dx}px`);
              s.style.setProperty("--dy", `${dy}px`);
              s.style.setProperty("--dur", `${dur}ms`);
              s.style.setProperty("--delay", `${Math.random() * 60}ms`);
              const color = 1 + Math.floor(Math.random() * 13);
              s.style.background = `var(--c${color})`;
              fw.appendChild(s);
            }

            el.fxLayer.appendChild(fw);
            setTimeout(() => fw.remove(), dur + 120);
          }
        }

        function animatePlaced(idxs, board) {
          if (!fxEnabled()) return;
          for (const idx of idxs) {
            const r = Math.floor(idx / 8);
            const c = idx % 8;
            if (board && board[r] && board[r][c] === 0) continue;
            const cell = boardCells[idx];
            if (!cell) continue;
            cell.classList.remove("placed", "placed-strong");
            void cell.offsetWidth;
            cell.classList.add("placed");
            if (fxStrong()) cell.classList.add("placed-strong");
            setTimeout(() => {
              cell.classList.remove("placed", "placed-strong");
            }, fxStrong() ? 320 : 220);
          }
        }

        // ===== Board helpers =====
        function emptyBoard() {
          return Array.from({ length: 8 }, () =>
            Array.from({ length: 8 }, () => 0)
          );
        }

        function cloneBoard(b) {
          return b.map((row) => row.slice());
        }

        function canPlace(board, piece, at) {
          for (const bl of piece.blocks) {
            const r = at.row + bl.y;
            const c = at.col + bl.x;
            if (r < 0 || r > 7 || c < 0 || c > 7) return false;
            if (board[r][c] !== 0) return false;
          }
          return true;
        }

        function place(board, piece, at) {
          const nb = cloneBoard(board);
          const colorId = piece.colorId || colorIdForShape(piece.shapeKey);
          for (const bl of piece.blocks) {
            nb[at.row + bl.y][at.col + bl.x] = colorId;
          }
          return nb;
        }

        function detectClears(board) {
          const rows = [];
          const cols = [];
          for (let r = 0; r < 8; r++) {
            let full = true;
            for (let c = 0; c < 8; c++) {
              if (board[r][c] === 0) {
                full = false;
                break;
              }
            }
            if (full) rows.push(r);
          }
          for (let c = 0; c < 8; c++) {
            let full = true;
            for (let r = 0; r < 8; r++) {
              if (board[r][c] === 0) {
                full = false;
                break;
              }
            }
            if (full) cols.push(c);
          }
          return { rows, cols };
        }

        function applyClears(board, clears) {
          const nb = cloneBoard(board);
          for (const r of clears.rows) {
            for (let c = 0; c < 8; c++) nb[r][c] = 0;
          }
          for (const c of clears.cols) {
            for (let r = 0; r < 8; r++) nb[r][c] = 0;
          }
          return nb;
        }

        function isPlaceableAnywhere(board, piece) {
          for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
              if (canPlace(board, piece, { row: r, col: c })) return true;
            }
          }
          return false;
        }

        function drawPiecePreferPlaceable(board, tries = 30) {
          for (let i = 0; i < tries; i++) {
            const p = pickRandomPiece();
            if (isPlaceableAnywhere(board, p)) return p;
          }
          return pickRandomPiece();
        }

        // ===== UI render =====
        const boardCells = [];
        function initBoardDOM() {
          el.board.innerHTML = "";
          boardCells.length = 0;
          for (let i = 0; i < 64; i++) {
            const d = document.createElement("div");
            d.className = "cell";
            d.dataset.idx = String(i);
            el.board.appendChild(d);
            boardCells.push(d);
          }
        }

        function clearPreview() {
          for (const idx of app.preview) {
            boardCells[idx].classList.remove("preview", "invalid");
          }
          app.preview = [];
        }

        function renderBoard() {
          const b = app.game.board;
          for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
              const idx = r * 8 + c;
              const cell = boardCells[idx];
              const val = b[r][c];
              cell.classList.toggle("filled", val !== 0);
              if (val !== 0) {
                cell.dataset.color = String(val);
                cell.style.background = `var(--c${val})`;
              } else {
                delete cell.dataset.color;
                cell.style.background = "";
              }
            }
          }
        }

        function renderHUD() {
          el.score.textContent = String(app.game.score);
          el.best.textContent = `Best: ${app.bestScore}`;
          setUndoEnabled(!!app.undo);
          renderLevel();
          renderTimer();
          renderLines();
        }

        function renderHome() {
          el.homeBest.textContent = String(app.bestScore);
        }

        function renderOver() {
          el.overScore.textContent = String(app.game.score);
          el.overBest.textContent = String(app.bestScore);
          el.overMsg.textContent =
            app.overMsgText ||
            (app.game.score >= app.bestScore
              ? "ベスト更新！"
              : "おつかれさまでした。");
          setUndoEnabled(!!app.undo);
        }

        function renderTray() {
          el.tray.innerHTML = "";
          for (const piece of app.game.hand) {
            const card = document.createElement("div");
            card.className = "piece-card";
            card.dataset.pieceId = piece.id;

            const pieceEl = document.createElement("div");
            pieceEl.className = "piece";
            pieceEl.dataset.pieceId = piece.id;
            pieceEl.dataset.color = String(
              piece.colorId || colorIdForShape(piece.shapeKey)
            );
            pieceEl.style.setProperty("--w", String(piece.w));
            pieceEl.style.setProperty("--h", String(piece.h));

            card.appendChild(pieceEl);
            el.tray.appendChild(card);

            for (const bl of piece.blocks) {
              const b = document.createElement("div");
              b.className = "pblock";
              b.style.left = `calc(var(--u) * ${bl.x})`;
              b.style.top = `calc(var(--u) * ${bl.y})`;
              pieceEl.appendChild(b);
            }
          }

          for (const card of el.tray.querySelectorAll(".piece-card")) {
            const pid = card.dataset.pieceId;
            const piece = app.game.hand.find((p) => p.id === pid);
            const pieceEl = card.querySelector(".piece");
            const rect = card.getBoundingClientRect();
            const pad = 10;
            const usableW = Math.max(80, rect.width - pad * 2);
            const usableH = Math.max(80, rect.height - pad * 2);
            const maxDim = Math.max(piece.w, piece.h);
            const u = Math.floor(Math.min(usableW, usableH) / maxDim);
            pieceEl.style.setProperty("--u", `${u}px`);
          }
        }

        function makePiece(proto) {
          return { ...proto, id: crypto.randomUUID() };
        }

        function newGame() {
          const g = {
            board: emptyBoard(),
            hand: [],
            score: 0,
            combo: 0,
            linesCleared: 0,
          };
          for (let i = 0; i < 3; i++) {
            g.hand.push(makePiece(drawPiecePreferPlaceable(g.board)));
          }
          return g;
        }

        // ===== Drag logic =====
        function nearestGrabBlock(pieceEl, piece, clientX, clientY) {
          const rect = pieceEl.getBoundingClientRect();
          const uStr = getComputedStyle(pieceEl).getPropertyValue("--u").trim();
          const u = Math.max(1, parseFloat(uStr || "24"));
          const lx = (clientX - rect.left) / u;
          const ly = (clientY - rect.top) / u;

          let best = piece.blocks[0];
          let bestD = Infinity;
          for (const bl of piece.blocks) {
            const cx = bl.x + 0.5;
            const cy = bl.y + 0.5;
            const dx = lx - cx;
            const dy = ly - cy;
            const d = dx * dx + dy * dy;
            if (d < bestD) {
              bestD = d;
              best = bl;
            }
          }
          return { x: best.x, y: best.y };
        }

        function boardMetrics() {
          const rect = el.board.getBoundingClientRect();
          const gap = parseFloat(getComputedStyle(el.board).gap || "0");
          const size = rect.width - 20;
          const cell = (size - gap * 7) / 8;
          const step = cell + gap;
          const originLeft = rect.left + 10;
          const originTop = rect.top + 10;
          return { gap, cell, step, originLeft, originTop, size };
        }

        function pointerToCell(clientX, clientY) {
          const m = boardMetrics();
          const x = clientX - m.originLeft;
          const y = clientY - m.originTop;
          if (x < 0 || y < 0 || x > m.size || y > m.size) return null;
          const col = Math.floor(x / m.step);
          const row = Math.floor(y / m.step);
          if (row < 0 || row > 7 || col < 0 || col > 7) return null;
          return { row, col };
        }

        function setPreview(piece, anchor, valid) {
          clearPreview();
          const idxs = [];
          for (const bl of piece.blocks) {
            const r = anchor.row + bl.y;
            const c = anchor.col + bl.x;
            if (r < 0 || r > 7 || c < 0 || c > 7) continue;
            idxs.push(r * 8 + c);
          }
          for (const idx of idxs) {
            boardCells[idx].classList.add("preview");
            if (!valid) boardCells[idx].classList.add("invalid");
          }
          app.preview = idxs;
        }

        function snapshotForUndo() {
          // 1手戻し用：ゲーム状態を丸ごとコピー
          app.undo = structuredClone(app.game);
          setUndoEnabled(true);
        }

        function applyUndo() {
          if (!app.undo) return;
          app.game = app.undo;
          app.undo = null;
          setUndoEnabled(false);
          initBoardDOM();
          renderBoard();
          renderHUD();
          renderTray();
          toast("1手戻しました");
        }

        function endGame(message) {
          stopTimer();
          clearPreview();
          app.overMsgText = message || null;
          renderOver();
          showScreen("over");
        }

        function levelUp() {
          if (!app.game) return;
          if (app.level >= MAX_LEVEL) return;
          app.level += 1;
          app.game.linesCleared = 0;
          app.overMsgText = null;
          app.timeLeft = TIMER_SECONDS;
          renderHUD();
          fxPop(`レベル${app.level}!`, "strong");
          flashBoard();
          fxFireworks(3);
          startTimer();
          app.undo = null;
          setUndoEnabled(false);
        }

        function celebrateClear() {
          fxPop("クリア!", "mega");
          flashBoard();
          fxFireworks(5);
          if (fxStrong()) {
            fxFireworks(4);
          }
        }

        function onTrayPointerDown(e) {
          const card = e.target.closest(".piece-card");
          if (!card || !app.game) return;

          const pid = card.dataset.pieceId;
          const piece = app.game.hand.find((p) => p.id === pid);
          if (!piece) return;

          const pieceEl = card.querySelector(".piece");
          const grab = nearestGrabBlock(pieceEl, piece, e.clientX, e.clientY);

          app.drag = {
            active: true,
            pieceId: pid,
            pointerId: e.pointerId,
            grab,
            canDrop: false,
            anchor: null,
          };

          card.setPointerCapture(e.pointerId);
          e.preventDefault();
        }

        function onTrayPointerMove(e) {
          if (!app.drag.active) return;
          if (e.pointerId !== app.drag.pointerId) return;

          const piece = app.game.hand.find((p) => p.id === app.drag.pieceId);
          if (!piece) return;

          const hover = pointerToCell(e.clientX, e.clientY);
          if (!hover) {
            clearPreview();
            app.drag.canDrop = false;
            app.drag.anchor = null;
            return;
          }

          const anchor = {
            row: hover.row - app.drag.grab.y,
            col: hover.col - app.drag.grab.x,
          };
          const valid = canPlace(app.game.board, piece, anchor);

          setPreview(piece, anchor, valid);
          app.drag.canDrop = valid;
          app.drag.anchor = anchor;
        }

        function onTrayPointerUp(e) {
          if (!app.drag.active) return;
          if (e.pointerId !== app.drag.pointerId) return;

          const pid = app.drag.pieceId;
          const piece = app.game.hand.find((p) => p.id === pid);

          if (piece && app.drag.canDrop && app.drag.anchor) {
            // Undo snapshot BEFORE applying this move
            snapshotForUndo();

            const placedCells = piece.blocks.length;
            const placedIdxs = piece.blocks.map(
              (bl) => (app.drag.anchor.row + bl.y) * 8 + (app.drag.anchor.col + bl.x)
            );
            let board2 = place(app.game.board, piece, app.drag.anchor);

            const clears = detectClears(board2);
            const lines = clears.rows.length + clears.cols.length;

            let add = placedCells * 5;
            if (lines > 0) {
              let mult = 1.0;
              if (lines === 2) mult = 1.2;
              if (lines === 3) mult = 1.5;
              if (lines >= 4) mult = 2.0;
              add += Math.round(lines * 100 * mult);
              app.game.combo += 1;
              add += app.game.combo * 50;
              app.game.linesCleared += lines;
              board2 = applyClears(board2, clears);
              toast(lines >= 2 ? `${lines}ライン消去 +${add}` : `消去 +${add}`);
            } else {
              app.game.combo = 0;
            }

            app.game.score += add;
            app.game.board = board2;

            app.game.hand = app.game.hand.filter((p) => p.id !== pid);

            while (app.game.hand.length < 3) {
              app.game.hand.push(
                makePiece(drawPiecePreferPlaceable(app.game.board))
              );
            }

            if (app.game.score > app.bestScore) {
              app.bestScore = app.game.score;
              saveBest(app.bestScore);
            }

            renderBoard();
            renderHUD();
            renderTray();

            bumpScore();
            animatePlaced(placedIdxs, board2);
            if (lines > 0) {
              flashBoard();
              fxPop(lines >= 2 ? `${lines}ライン!` : "ライン消去!");
              fxFireworks(lines >= 2 ? 2 : 1);
            }
            if (app.game.score >= app.bestScore && app.game.score === app.bestScore) {
              fxPop("ベスト!");
              fxFireworks(2);
            }
            if (app.game.linesCleared >= currentGoal()) {
              if (app.level < MAX_LEVEL) {
                levelUp();
              } else {
                celebrateClear();
                endGame("クリア！");
              }
              return;
            }

            const any = app.game.hand.some((p) =>
              isPlaceableAnywhere(app.game.board, p)
            );
            if (!any) {
              endGame();
            }
          }

          clearPreview();
          app.drag = { active: false };
        }

        function onTrayPointerCancel() {
          if (!app.drag.active) return;
          clearPreview();
          app.drag = { active: false };
        }

        // ===== Modal =====
        function openModal() {
          el.modalback.style.display = "flex";
          el.modalback.setAttribute("aria-hidden", "false");
          document.body.classList.add("modal-open");
          clearPreview();
          app.drag = { active: false };
          pauseTimer();
        }
        function closeModal() {
          el.modalback.style.display = "none";
          el.modalback.setAttribute("aria-hidden", "true");
          document.body.classList.remove("modal-open");
          resumeTimer();
        }

        // ===== Copy result =====
        async function copyResult() {
          if (!app.game) return;
          const dt = new Date().toLocaleString("ja-JP");
          const text = `Private Block Puzzle
Score: ${app.game.score}
Best: ${app.bestScore}
Date: ${dt}
URL: ${location.href}`;
          try {
            await navigator.clipboard.writeText(text);
            toast("結果をコピーしました");
          } catch {
            // fallback
            window.prompt(
              "コピーできない環境のため、以下を手動コピーしてください。",
              text
            );
          }
        }

        // ===== Actions =====
        function startFreshGame() {
          app.level = 1;
          app.game = newGame();
          app.undo = null;
          app.overMsgText = null;
          app.timeLeft = TIMER_SECONDS;
          initBoardDOM();
          renderBoard();
          renderHUD();
          renderTray();
          showScreen("game");
          startTimer();
        }

        el.btnStart.addEventListener("click", startFreshGame);
        el.btnAgain.addEventListener("click", startFreshGame);

        el.btnHome.addEventListener("click", () => {
          app.game = null;
          app.undo = null;
          app.overMsgText = null;
          stopTimer();
          renderHome();
          showScreen("home");
        });

        el.btnRestart.addEventListener("click", () => {
          const ok = confirm(
            "リスタートしますか？（現在のスコアは失われます）"
          );
          if (!ok) return;
          startFreshGame();
          toast("リスタート");
        });

        el.btnUndo.addEventListener("click", () => {
          if (!app.game || !app.undo) return;
          applyUndo();
        });

        el.btnUndoOver.addEventListener("click", () => {
          if (!app.game || !app.undo) return;
          applyUndo();
          showScreen("game");
        });

        el.btnCopy.addEventListener("click", copyResult);

        el.btnSettingsHome.addEventListener("click", openModal);
        el.btnSettingsGame.addEventListener("click", openModal);
        el.btnCloseModal.addEventListener("click", closeModal);
        el.btnOkModal.addEventListener("click", () => {
          saveSettings(app.settings);
          closeModal();
        });

        el.btnResetBest.addEventListener("click", () => {
          const ok = confirm("自己ベストをリセットしますか？");
          if (!ok) return;
          app.bestScore = 0;
          saveBest(0);
          renderHome();
          if (app.game) renderHUD();
          toast("ベストをリセット");
        });

        el.swEffects.addEventListener("click", () => {
          const cur = app.settings.effects;
          app.settings.effects =
            cur === "off" ? "low" : cur === "low" ? "high" : "off";
          applyTheme();
          saveSettings(app.settings);
        });

        // tray pointer events
        el.tray.addEventListener("pointerdown", onTrayPointerDown);
        el.tray.addEventListener("pointermove", onTrayPointerMove);
        el.tray.addEventListener("pointerup", onTrayPointerUp);
        el.tray.addEventListener("pointercancel", onTrayPointerCancel);

        // init
        applyTheme();
        renderHome();
        setUndoEnabled(false);
        showScreen("home");
      })();
    </script>
  </body>
</html>
